package providers

import (
	"context"
	"errors"

	"github.com/openai/openai-go"
)

type ProviderConfig struct {
	Messages []ProviderMessage `json:"messages"`
}

// ProviderMessage represents a chat message
type ProviderMessage struct {
	// The contents of the message.
	Content string `json:"content"`
	// The role of the author of this message.
	Role ProviderMessageRole `json:"role"`
	// The tool calls generated by the model, such as function calls.
	ToolCalls []openai.ChatCompletionMessageToolCall `json:"tool_calls,omitempty"`
}

// The role of the author of this message.
type ProviderMessageRole string

const (
	ProviderMessageRoleAssistant ProviderMessageRole = "assistant"
	ProviderMessageRoleUser      ProviderMessageRole = "user"
	ProviderMessageRoleSystem    ProviderMessageRole = "system"
	ProviderMessageRoleTool      ProviderMessageRole = "tool"
)

// Provider defines the interface that all provider clients must implement
type Provider interface {
	ChatCompletion(ctx context.Context, messages []any) (any, error)
	SummariseMessages(messages []any) (any, error)
}

// ProviderClient wraps a Provider implementation
type ProviderClient struct {
	ProviderName string
	provider     Provider
}

// NewClient creates a new provider client based on the provider name
func NewClient(providerName string) (*ProviderClient, error) {
	switch providerName {
	case "openai":
		client, err := NewOpenAIClient()
		if err != nil {
			return nil, err
		}
		return &ProviderClient{
			ProviderName: providerName,
			provider:     client,
		}, nil
	default:
		return nil, errors.New("unsupported provider")
	}
}

// ChatCompletion delegates to the underlying provider's ChatCompletion
func (c *ProviderClient) ChatCompletion(ctx context.Context, messages []ProviderMessage) (any, error) {
	mappedMessages, err := MapProviderMessages(c.ProviderName, messages)
	if err != nil {
		return nil, err
	}
	return c.provider.ChatCompletion(ctx, mappedMessages)
}

// SummariseMessages delegates to the underlying provider's SummariseMessages
func (c *ProviderClient) SummariseMessages(messages []ProviderMessage) (any, error) {
	mappedMessages, err := MapProviderMessages(c.ProviderName, messages)
	if err != nil {
		return nil, err
	}
	return c.provider.SummariseMessages(mappedMessages)
}

func MapProviderMessages(providerName string, providerMessages []ProviderMessage) ([]any, error) {
	var (
		err      error
		messages = make([]any, len(providerMessages))
	)

	for i, msg := range providerMessages {
		messages[i], err = MapProviderMessage(providerName, msg)
		if err != nil {
			return nil, err
		}
	}
	return messages, nil
}

func MapProviderMessage(providerName string, message ProviderMessage) (any, error) {
	switch providerName {
	case "openai":
		return MapOpenAIProviderMessage(message), nil
	default:
		return nil, errors.New("unsupported provider")
	}
}

func UnmapProviderMessage(providerName string, message any) (ProviderMessage, error) {
	switch providerName {
	case "openai":
		return UnmapOpenAIProviderMessage(message.(openai.ChatCompletionMessage)), nil
	default:
		return ProviderMessage{}, errors.New("unsupported provider")
	}
}
